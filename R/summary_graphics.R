### Imports

#' @import dplyr
#' @import ggplot2
#' @import phyloseq
#' @import rlang
NULL

### Objects
cols_21 = c("#4f8579","#783fcc","#69d24d","#cb4bbd","#c6dc46","#542871",
            "#78d792","#cc4472","#83d7d0","#d44d33","#676fcd","#ceb854",
            "#403d57","#b97839","#84a4cb","#588038","#c68ac4","#48472a",
            "#c9c39c","#6e2b34","#c78889")
################################################################################
### Functions to generate summarizing graphics
################################################################################

### Deal with data -------------------------------------------------------------
#### Deal with taxa ------------------------------------------------------------

##### remain -------------------------------------------------------------------

#' Calculate the remainder for the 'Other' section of a phyloseq data frame.
#'
#' @section Value: a numeric vector
#'
#' @param x A numeric vector
#' @param tot The desired total. Default is 1.
remain = function(x, tot = 1){
    tot-sum(x)
}

##### prop_tax_row -------------------------------------------------------------

#' Propagate taxon information in a single row of a \code{tax_table} object.
#'
#' \code{prop_tax_row} Takes the taxon assignment from the lowest assigned level
#' in an OTU's assignment and fills it in to all the lower, unresolved fields.
#'
#' @section Details: Often taxon cannot be assigned all the way down to genus
#'   from the limited information available from a given variable region of 16S
#'   (or other marker gene). If an OTU has been assigned to Order
#'   Enterobacteriales, but the Family and genus cannot be resolved, then the
#'   Family and Genus fields are left blank by QIIME. This function fills those
#'   fields with the string 'o_Enterobacteriales', so they are not parsed as NAs
#'   by ggplot and other functions.
#'
#' @section Value: A single row \code{tax_table} object to with NAs replaced
#'   with higher-level taxon assignments
#'
#' @param taxrow A single row in a taxon table
#' @param dada2 a flag to indicate if the data tables were generated by dada2.
#'   If FALSE, it's assumed they were generated by QIIME 1.
#'
#' @keywords internal
prop_tax_row = function(taxrow,dada2){
	## taxrow: a row from a tax_table of a phyloseq object

	ranks = colnames(taxrow)

	hasNA = FALSE
	for (i in 1:length(ranks)){

	    if (!is.na(taxrow[,ranks[i]])){
	        tax = taxrow[,ranks[i]]
	    } else {
	        hasNA = TRUE
	        break
	    }
	}

	if (!hasNA){
		return (taxrow)
	} else {
		init = tolower(substring(ranks[i-1],1,1))
		if (dada2){
		    assn = tax
		} else {
		    assn = paste(init,tax,sep = '_')
		}
		taxrow[,ranks[i:length(ranks)]] = assn
		return(taxrow)
	}
}

##### prop_tax_tab -------------------------------------------------------------

#' Propagate taxon information down an entire \code{tax_table} object
#'
#' \code{prop_tax_tab} Takes the taxon assignment from the lowest assigned level
#' in an OTU's assignment and fills it in to all the lower, unresolved fields.
#'
#' @section Details: Often taxon cannot be assigned all the way down to genus
#'   from the limited information available from a given variable region of 16S
#'   (or other marker gene). If an OTU has been assigned to Order
#'   Enterobacteriales, but the Family and genus cannot be resolved, then the
#'   Family and Genus fields are left blank by QIIME. This function fills those
#'   fields with the string 'o_Enterobacteriales', so they are not parsed as NAs
#'   by ggplot and other functions.
#'
#' @section Value: A \code{tax_table} object with NAs replaced with higher-level
#'   taxon assignment
#'
#' @param taxtab a \code{tax_table} object
#' @param dada2 a flag to indicate if the data tables were generated by dada2.
#'   If FALSE, it's assumed they were generated by QIIME 1. Just gets passed to
#'   \code{prop_tax_row()}.
#'
#' @keywords internal
prop_tax_tab = function(taxtab, dada2){

    ## I don't know why I can't use apply for this, but I can't.
    for (r in 1:nrow(taxtab)){
        taxtab[r,] = prop_tax_row(taxtab[r,], dada2)
    }

    return(taxtab)
}

##### prop_tax_down ------------------------------------------------------------

#' Propagate taxon information down an entire \code{tax_table} in a phylose
#' object
#'
#' \code{prop_tax_down} Takes the taxon assignment from the lowest assigned
#' level in an OTU's assignment and fills it in to all the lower, unresolved
#' fields.
#'
#' @section Details: Often taxon cannot be assigned all the way down to genus
#'   from the limited information available from a given variable region of 16S
#'   (or other marker gene). If an OTU has been assigned to Order
#'   Enterobacteriales, but the Family and genus cannot be resolved, then the
#'   Family and Genus fields are left blank by QIIME. This function fills those
#'   fields with the string 'o_Enterobacteriales', so they are not parsed as NAs
#'   by ggplot and other functions.
#'
#' @section Value: A phyloseq object whose \code{tax_table} has had NAs replaced
#'   with the higher level taxon assignments.
#'
#' @param physeq a phyloseq object with a filled \code{tax_table} slot.
#' @param dada2 a flag to indicate whether the data tables were generated in
#'   dada2 or not. If not, it's assumed they were generated in QIIME 1. Just
#'   gets passed to \code{prop_tax_tab()}.
prop_tax_down = function(physeq, dada2){
    tax_table(physeq) = prop_tax_tab(tax_table(physeq), dada2)
    return(physeq)
}

#### Create the data frame for plotting ----------------------------------------

##### make_phy_df --------------------------------------------------------------

#' Generate a Data Frame for Taxon Bar Charts
#'
#' \code{make_phy_df} generates a data frame that is useful for generating taxon
#' bar charts.
#'
#' @section Details: This function takes a phyloseq object and generates a data
#'   frame that is useful for plotting taxon abundance information. By default
#'   it propagates taxon assignment information down the tree into unassigned
#'   leves, and aggregates all taxa below 0.1 percent into a single 'Other'
#'   category. This function expects the phyloseq object to be relative
#'   abundance, and weird things will happen if it is not.
#'
#' @section Value: A data frame similar in structure to that generated by
#'   \code{psmelt}, but with an 'Other' category added and taxon levels ordered
#'   for use in plotting.
#'
#' @param physeq A phyloseq object.
#' @param rank The rank at which to glom taxa. Must be one of 'Genus', 'Family',
#'   'Order', 'Class', 'Phylum'. Default is 'Genus'. TODO: make it possible to
#'   do this OTU-wise.
#' @param cutoff The abundance cutoff below which taxa are grouped into 'Other'.
#'   If you don't want anything grouped into 'Other', set this to 0. Default is
#'   0.001.
#' @param dada2 Specifies whether the object comes from dada2 output. If FALSE,
#'   assumes the object was generated by QIIME 1.
make_phy_df = function(physeq, rank = 'Genus', cutoff = 0.001, dada2 = FALSE){


    # Deal with the case where the object was generated by DADA2
    if (dada2){
        tt = tax_table(physeq)
        ifelse(endsWith(c(tt), '__'),
               NA,
               c(tt)) %>%
            matrix(ncol = ncol(tt)) -> tt
        ranks = colnames(tax_table(physeq))
        colnames(tt) = ranks
        tax_table(physeq) = tt
    }

	# Propogate taxonomic assignments down the tree
    physeq = prop_tax_down(physeq, dada2)

	# Glom to the correct taxonomic rank
	phyl_glommed = tax_glom(physeq, taxrank = rank)

	# Set all counts < the cutoff to zero
	otu_table(phyl_glommed)[otu_table(phyl_glommed) < cutoff] = 0

	# Filter out all taxa that are zero (<cutoff) everywhere, melt, and sort
	phyl_glommed %>%
		filter_taxa(function(x) sum(x) > 0, prune = TRUE) %>%
		psmelt() %>%
		data.frame() -> abunds

	# Order the rank by mean abundance

	abunds %>%
		group_by(UQ(sym(rank))) %>%
		summarize(Mean = mean(Abundance)) %>%
		data.frame() -> mean_abunds

	lev_ord = levels(mean_abunds[,rank])
	lev_ord = lev_ord[order(mean_abunds$Mean)]

	abunds[,rank] = factor(abunds[,rank], levels = lev_ord)

	# List all the metadata columns so that they are included in the data frame
	metacols = names(abunds)[4:(match(ranks[1],names(abunds))-1)]
	# Make an 'Other' row for each sample
	abunds %>%
		group_by_(.dots = metacols) %>%
		summarize(Abundance=remain(Abundance)) -> others

	# Add in the taxonomic data columns
	taxcols = names(abunds)[match(ranks[1],names(abunds)):ncol(abunds)]
	others[taxcols] = 'Other'

	# Combine the 'Other' data frame with the original
	newdf = abunds[,metacols]
	newdf$Abundance = abunds$Abundance
	newdf[,taxcols] = abunds[,taxcols]
	newdf = rbind(as.data.frame(others),
				as.data.frame(newdf))
	newdf[,rank] = factor(newdf[,rank], levels = c('Other',lev_ord))

	return(newdf)

}


### Generate Plots -------------------------------------------------------------

#### plot_tax_bar --------------------------------------------------------------

#' Create a Taxa Bar Chart
#'
#' \code{plot_tax_bar} creates a taxa bar chart from the data frame generated by
#' \code{make_phy_df()}.
#'
#' @section Details:
#'   This function generates a ggplot object that is a
#'   first-pass, reasonable attempt at a taxon bar chart. The taxa are ordered
#'   by mean abundance and the 'Other' category is at the top. Because it's a
#'   regular ggplot object, you can add more geoms or facet it or manipulate it
#'   however you like using ggplot functions.
#'
#' @section Value:
#'   A ggplot object.
#'
#' @param tax_df The data frame used for plotting. Unless you really know what
#'   you're doing, use the data frame output by \code{make_phy_df()}.
#' @param rank The taxonomic rank at which to view the data. Must be one of
#'   'Genus', 'Family', 'Order', 'Class', 'Phylum'. May not be a lower rank than
#'   the rank given to \code{make_phy_df()}.
#' @param colours A character vector of colour names or hex values. Must have
#'   enough colours to accommodate all your taxa at the appropriate rank. If you
#'   don't provide one, there is an internal one that has 21 colours that the
#'   function will try to use.
#' @param sample The name of the sample column in the data frame.
#' @param abund The name of the abundance column in the data frame.
#' @param yscale Can be either 'lin' or 'sqrt'. The 'sqrt' plot can look weird.
plot_tax_bar = function(taxa_df,rank,colours = NULL,
					 sample = 'X.SampleID', abund = 'Abundance',
					 yscale = 'lin'){
	## taxa_df:	The data frame produced by taxa_other_df()
	## rank: The taxonomic rank to plot by
	## colours:	A character vector with the right number of colours. If you
	## don't provide one it uses my 21-colour vector, which might not be enough
	## left NULL, the bars will be ordered alphabetically by sample ID.
	## sample: the name of the sample ID column.
	## abund: the name of the abundance column

	# Check the inputs
	if (!(sample %in% names(taxa_df))){
		stop('sample argument must be one of the columns in your data frame')
	}

	if (!(abund %in% names(taxa_df))){
		stop('abund argument must be one of the columns in your data frame')
	}

	if (!(yscale %in% c('lin','log','sqrt'))){
		stop('yscale argument must be one of \'lin\', \'log\', or \'sqrt\'')
	}

	# Pick colours
	if (is.null(colours)){
		colours = c('grey69',cols_21)
	} else {
		colours = c('grey69',colours)
	}

	# Make sure the x axis is categorical
	taxa_df[,sample] = factor(taxa_df[,sample])

	indiv = ggplot(taxa_df, aes_string(x = sample, y = abund, fill = rank)) +
	geom_bar(stat = "identity") +
	theme(axis.title.x = element_blank(),
			axis.text.x = element_text(size = 10,
									   angle = 90,
									   hjust = 1,
									   vjust = 0.5)) +
	scale_fill_manual(values = colours, guide = guide_legend(reverse = TRUE)) +
	ylab(paste("Relative Abundance (",rank,")\n",sep=''))

	if (yscale == 'sqrt') {
		indiv = indiv + scale_y_sqrt()
	}

	return(indiv)
}

#### plot_read_depth -----------------------------------------------------------

#' Plot read depth
#'
#' Creates a read depth histogram.
#' @param physeq A phyloseq object
plot_read_depth = function(physeq){
    sample_sum_df = data.frame(Total = sample_sums(physeq),
                               sample_data(physeq))
    depth_plot = ggplot(sample_sum_df, aes(x = log10(Total))) +
        geom_histogram(colour = 'black', fill = 'grey57') +
        #scale_x_log10() +
        xlab('Log10 read depth') +
        ylab('Number of samples') +
        ggtitle('Distribution of read depths')
    return(depth_plot)
}

#### plot_abundance_violing ----------------------------------------------------

#' Make violin plots of taxon abundance
#'
#' @param phy_df A data frame constructed from a phyloseq object, as with
#'   \code{psmelt()} (or \code{make_phy_df()})
#' @param f1,f2 Two columns to facet by. If both are used, the first will be
#'   rows and the second will be columns.
#' @param col_by A column to colour points by. If this column has more than 21
#'   unique values, you must provide your own list of colours with the
#'   \code{colours} parameter.
#' @param colours An optional vector of colours to use when colouring the
#'   points.
plot_taxon_violin = function(phy_df, f1 = NULL, f2 = NULL, col_by = NULL,
                             colours = NULL){
    plt = ggplot(phy_df, aes(x = extraction, y = Abundance))
    if (!is.null(col_by)){
        if (is.null(colours)){
            colours = cols_21
        }
        plt = plt + geom_point(aes_string(colour = col_by),
                               alpha = 0.3,
                               position = position_jitter(width = 0.3)) +
            scale_colour_manual(values = colours)
    } else {
        plt = plt + geom_point(alpha = 0.3,
                               position = position_jitter(width = 0.3),
                               colour = 'goldenrod')
    }
    plt = plt + geom_violin(fill = NA)

    if (!is.null(f1)){
        if (!is.null(f2)){
            form = formula(paste(f1, '~', f2))
            plt = plt + facet_grid(form)
        } else {
            form = formula(paste('~', f1))
            plt = plt + facet_wrap(form)
        }
    } else if (!is.null(f2)){
        form = formula(paste('~', f2))
        plt = plt + facet_wrap(form)
    }
    plt = plt + scale_y_log10()

    return(plt)
}
