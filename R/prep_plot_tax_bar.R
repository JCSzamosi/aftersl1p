## df_glom ------------------------------------------------------------------

#' Like tax_glom, but for data frames
#'
#' \code{df_glom} take totals within sample at a given taxonomic rank.
#'
#' @param phy_df A phyloseq data frame, as generated by \code{\link{psmelt}} or
#'   \code{\link{make_phy_df}}
#' @param ranks A character vector with the taxon rank names
#' @param IDcol The column name of the sample IDs
#' @param rank The taxonomic rank to glom at
#' @param abunds The column name of the abundances to sum
#' @param tots The desired column name of the summed (glommed) abundances
df_glom = function(phy_df, ranks, IDcol = 'X.SampleID', rank = 'Phylum',
                   abunds = 'Abundance'){

    # Set up the groups for the plotting totals
    phy_df %>%
        dplyr::group_by_at(vars(IDcol,rank)) %>%
        dplyr::mutate(TotalAbunds = sum(UQ(sym(abunds)))) %>%
        data.frame() -> glommed_df

    return(glommed_df)
}

## subset_order -------------------------------------------------------------

#' Subset and generate taxon ordering
#'
#' \code{subset_order} generates a data frame whose taxon column given by
#' \code{rank} has been ranked according to its mean abundance in the
#' \code{abunds} column.
#'
#' @param phy_df A phyloseq data frame, as generated by \code{\link{psmelt}}, but
#'   probably generated by \code{\link{df_glom}}.
#' @param varbs (\code{NULL}) A character vector of grouping variables from
#'   which the baseline values are chosen to define the abundance ordering. If
#'   it is \code{NULL}, the ordering will be based on mean abundances in the
#'   whole data frame.
#' @param bases (\code{NULL}) A character vector of baseline values for the
#'   variables given in \code{vars}. The ordering of the taxa will be given
#'   based only on the samples with these baseline values for these variables.
#'   Must be in the same order as varbs.
#' @param abund (\code{'Abundance'}) The name of the abundance column.
#' @param rank (\code{'Genus'}) The rank to base the ordering on.
subset_order = function(phy_df, varbs = NULL, bases = NULL, rank = 'Genus',
                        abunds = 'TotalAbunds'){
    # Check inputs
    if (is.null(varbs)){
        warn('No grouping variables given. Using whole data set.')
    } else if (is.null(bases)){
        warn(paste('No baseline values given for grouping variables.',
                    'Using whole data set.'))
    } else if (length(varbs) != length(bases)){
        stop('vars and bases must have the same length.')
    }


    # Subset and order
    ranked = phy_df
    for(i in 1:length(varbs)){
        ranked %>% dplyr::filter(UQ(sym(varbs[i])) == bases[i]) -> ranked
    }
    ranked %>%
        dplyr::group_by_at(vars(c(varbs,rank))) %>%
        dplyr::summarize(MetaMean = mean(UQ(sym(abunds)))) %>%
        data.frame() %>%
        order_taxa(rank, 'MetaMean', decreasing = TRUE) -> ranked

    return(ranked)
}

## rank_abund ---------------------------------------------------------------

#' Rank Taxa by Abundance
#'
#' \code{rank_abund()} generates a data frame that's ready to be used by
#' \code{\link{plot_rank_abund}}
#'
#' @section Value: A data frame whose taxa have been ranked by their mean
#'   abundance in the baseline level of some grouping variable or variables.
#'
#' @param phy_df A dataframe of a phyloseq object, like that generated by
#'   \code{\link{psmelt}} or \code{\link{make_phy_df}}
#' @param varbs (\code{NULL}) A character vector of grouping variables from
#'   which the baseline values are chosen to define the abundance ordering. If
#'   it is \code{NULL}, the ordering will be based on mean abundances in the
#'   whole data frame.
#' @param bases (\code{NULL}) A character vector of baseline values for the
#'   variables given in \code{vars}. The ordering of the taxa will be given
#'   based only on the samples with these baseline values for these variables.
#'   Must be in the same order as vars.
#' @param abunds (\code{'Abundance'}) The name of the abundance column.
#' @param rank (\code{'Genus'}) The rank to base the ordering on.
#' @param IDcol (\code{'X.SampleID'}) The column name of the sample IDs
rank_abund = function(phy_df, varbs = NULL, bases = NULL, abunds = 'Abundance',
                      rank = 'Genus', IDcol = 'X.SampleID'){
    # Set up the groups for the plotting totals
    rank_abs = df_glom(phy_df, IDcol = IDcol, rank = rank, abunds = abunds)

    # Subset and order
    ranked = subset_order(rank_abs, varbs, bases, rank = rank)

    # Order the bigger data frame by the above ordering
    lev_ord = levels(ranked[,rank])
    rank_abs[,rank] = factor(rank_abs[,rank], levels = lev_ord)

    return(rank_abs)
}


#### order_levs

#' Order the levels of one factor by the values of another
#'
#' \code{order_levs()} takes two factors, the first of which has values that are
#' nested within the values of the second, and orders the levels of the first
#' factor such that they are clustered within the second factor.
#'
#' @section Value: A factor that has the same levels as f1, but that has been
#'   re-ordered.
#'
#' @param f1 The factor to re-order. Levels of this factor must be nested within
#'   \code{f2}
#' @param f2 The factor to use when re-ordering \code{f1}.
order_levs = function(f1,...){

    # if (is.numeric(f2)){
    #     ord = order(...)
    # } else {
        ord = order(...) # don't revert this to as-character. It needs to respect
                        # f2's level ordering. Find another way.
    # }

    lev_ord = unique(as.character(f1)[ord])
    f1 = factor(f1, levels = lev_ord)

    return(f1)
}

## rotate_ticks --------------------------------------------------------------

#' Rotate the x tick labels 90 degrees and position them correctly.
#'
rotate_ticks = function(){
    theme(axis.text.x = element_text(size = 10,
                                     angle = 90,
                                     hjust = 1,
                                     vjust = 0.5))
}
