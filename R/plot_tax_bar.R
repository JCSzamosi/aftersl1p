##### df_glom ------------------------------------------------------------------

#' Like tax_glom, but for data frames
#'
#' \code{df_glom} take totals within sample at a given taxonomic rank.
#'
#' @param phy_df A phyloseq data frame, as generated by \code{\link{psmelt}} or
#'   \code{\link{make_phy_df}}
#' @param ranks A character vector with the taxon rank names
#' @param IDcol The column name of the sample IDs
#' @param rank The taxonomic rank to glom at
#' @param abunds The column name of the abundances to sum
#' @param tots The desired column name of the summed (glommed) abundances
df_glom = function(phy_df, ranks, IDcol = 'X.SampleID', rank = 'Phylum',
                   abunds = 'Abundance'){

    # Set up the groups for the plotting totals
    phy_df %>%
        dplyr::group_by_at(vars(IDcol,rank)) %>%
        dplyr::mutate(TotalAbunds = sum(UQ(sym(abunds)))) %>%
        data.frame() -> glommed_df

    return(glommed_df)
}

##### subset_order -------------------------------------------------------------

#' Subset and generate taxon ordering
#'
#' \code{subset_order} generates a data frame whose taxon column given by
#' \code{rank} has been ranked according to its mean abundance in the
#' \code{abunds} column.
#'
#' @param phy_df A phyloseq data frame, as generated by \code{\link{psmelt}}, but
#'   probably generated by \code{\link{df_glom}}.
#' @param varbs (\code{NULL}) A character vector of grouping variables from
#'   which the baseline values are chosen to define the abundance ordering. If
#'   it is \code{NULL}, the ordering will be based on mean abundances in the
#'   whole data frame.
#' @param bases (\code{NULL}) A character vector of baseline values for the
#'   variables given in \code{vars}. The ordering of the taxa will be given
#'   based only on the samples with these baseline values for these variables.
#'   Must be in the same order as varbs.
#' @param abund (\code{'Abundance'}) The name of the abundance column.
#' @param rank (\code{'Genus'}) The rank to base the ordering on.
subset_order = function(phy_df, varbs = NULL, bases = NULL, rank = 'Genus',
                        abunds = 'TotalAbunds'){
    # Check inputs
    if (is.null(varbs)){
        warn('No grouping variables given. Using whole data set.')
    } else if (is.null(bases)){
        warn(paste('No baseline values given for grouping variables.',
                    'Using whole data set.'))
    } else if (length(varbs) != length(bases)){
        stop('vars and bases must have the same length.')
    }


    # Subset and order
    ranked = phy_df
    for(i in 1:length(varbs)){
        ranked %>% dplyr::filter(UQ(sym(varbs[i])) == bases[i]) -> ranked
    }
    ranked %>%
        dplyr::group_by_at(vars(c(varbs,rank))) %>%
        dplyr::summarize(MetaMean = mean(UQ(sym(abunds)))) %>%
        data.frame() %>%
        order_taxa(rank, 'MetaMean', decreasing = TRUE) -> ranked

    return(ranked)
}

##### rank_abund ---------------------------------------------------------------

#' Rank Taxa by Abundance
#'
#' \code{rank_abund()} generates a data frame that's ready to be used by
#' \code{\link{plot_rank_abund}}
#'
#' @section Value: A data frame whose taxa have been ranked by their mean
#'   abundance in the baseline level of some grouping variable or variables.
#'
#' @param phy_df A dataframe of a phyloseq object, like that generated by
#'   \code{\link{psmelt}} or \code{\link{make_phy_df}}
#' @param varbs (\code{NULL}) A character vector of grouping variables from
#'   which the baseline values are chosen to define the abundance ordering. If
#'   it is \code{NULL}, the ordering will be based on mean abundances in the
#'   whole data frame.
#' @param bases (\code{NULL}) A character vector of baseline values for the
#'   variables given in \code{vars}. The ordering of the taxa will be given
#'   based only on the samples with these baseline values for these variables.
#'   Must be in the same order as vars.
#' @param abunds (\code{'Abundance'}) The name of the abundance column.
#' @param rank (\code{'Genus'}) The rank to base the ordering on.
#' @param IDcol (\code{'X.SampleID'}) The column name of the sample IDs
rank_abund = function(phy_df, varbs = NULL, bases = NULL, abunds = 'Abundance',
                      rank = 'Genus', IDcol = 'X.SampleID'){
    # Set up the groups for the plotting totals
    rank_abs = df_glom(phy_df, IDcol = IDcol, rank = rank, abunds = abunds)

    # Subset and order
    ranked = subset_order(rank_abs, varbs, bases, rank = rank)

    # Order the bigger data frame by the above ordering
    lev_ord = levels(ranked[,rank])
    rank_abs[,rank] = factor(rank_abs[,rank], levels = lev_ord)

    return(rank_abs)
}


#### order_levs

#' Order the levels of one factor by the values of another
#'
#' \code{order_levs()} takes two factors, the first of which has values that are
#' nested within the values of the second, and orders the levels of the first
#' factor such that they are clustered within the second factor.
#'
#' @section Value: A factor that has the same levels as f1, but that has been
#'   re-ordered.
#'
#' @param f1 The factor to re-order. Levels of this factor must be nested within
#'   \code{f2}
#' @param f2 The factor to use when re-ordering \code{f1}.
order_levs = function(f1,...){

    # if (is.numeric(f2)){
    #     ord = order(...)
    # } else {
        ord = order(...) # don't revert this to as-character. It needs to respect
                        # f2's level ordering. Find another way.
    # }

    lev_ord = unique(as.character(f1)[ord])
    f1 = factor(f1, levels = lev_ord)

    return(f1)
}

### Generate Plots -------------------------------------------------------------

#### rotate_ticks --------------------------------------------------------------

#' Rotate the x tick labels 90 degrees and position them correctly.
#'
rotate_ticks = function(){
    theme(axis.text.x = element_text(size = 10,
                                     angle = 90,
                                     hjust = 1,
                                     vjust = 0.5))
}

#### plot_tax_bar --------------------------------------------------------------

#' Create a Taxa Bar Chart
#'
#' \code{plot_tax_bar()} creates a taxa bar chart from the data frame generated
#' by \code{\link{make_phy_df}}.
#'
#' @section Details: This function generates a ggplot object that is a
#'   first-pass, reasonable attempt at a taxon bar chart. The taxa are ordered
#'   by mean abundance and the 'Other' category is at the top. Because it's a
#'   regular ggplot object, you can add more geoms or facet it or manipulate it
#'   however you like using ggplot functions.
#'
#' @section Value: A ggplot object.
#'
#' @param tax_df The data frame used for plotting. Unless you really know what
#'   you're doing, use the data frame output by \code{\link{make_phy_df}}.
#' @param rank The taxonomic rank at which to view the data. Must be one of
#'   'Genus', 'Family', 'Order', 'Class', 'Phylum'. May not be a lower rank than
#'   the rank given to \code{\link{make_phy_df}}.
#' @param colours A character vector of colour names or hex values. Must have
#'   enough colours to accommodate all your taxa at the appropriate rank. If you
#'   don't provide one, there are a few internal vectors that have 21, 31, 60,
#'   or 70 colours that the function will try to use.
#' @param sample The name of the sample column in the data frame.
#' @param abund The name of the abundance column in the data frame.
#' @param legloc Location of the legend. Can be 'right' (default), 'bottom', or
#'   'none' (absent)
#' @param yscale Can be either 'lin' or 'sqrt'. The 'sqrt' plot can look weird.
#' @param means If \code{TRUE}, sets \code{position = fill} in the
#'   \code{geom_bar()} to constrain the abundances to sum to 1. Good to use if
#'   your \code{sample = } parameter is not actually sample names, but rather
#'   larger categories, to produce means.
#' @export
plot_tax_bar = function(taxa_df,rank,colours = NULL,
					 sample = 'X.SampleID', abund = 'Abundance',
					 legloc = 'right', yscale = 'lin', means = FALSE){
	## taxa_df:	The data frame produced by taxa_other_df()
	## rank: The taxonomic rank to plot by
	## colours:	A character vector with the right number of colours. If you
	## don't provide one it uses my 21-colour vector, which might not be enough
	## left NULL, the bars will be ordered alphabetically by sample ID.
	## sample: the name of the sample ID column.
	## abund: the name of the abundance column

	# Check the inputs
	if (!(sample %in% names(taxa_df))){
		stop('sample argument must be one of the columns in your data frame')
	}

	if (!(abund %in% names(taxa_df))){
		stop('abund argument must be one of the columns in your data frame')
	}

	if (!(yscale %in% c('lin','log','sqrt'))){
		stop('yscale argument must be one of \'lin\', \'log\', or \'sqrt\'')
	}

	# Pick colours
	if (is.null(colours)){
		num = length(unique(taxa_df[,rank]))
		if (num <= 22){
			colours = c('grey69',rev(cols_21[1:(num-1)]))
		} else if (num <= 31) {
			colours = c('grey69',rev(cols_31[1:(num-1)]))
		} else if (num <= 61) {
			colours = c('grey69',rev(cols_60[1:(num-1)]))
		} else if (num <= 71) {
			colours = c('grey69',rev(cols_70[1:(num-1)]))
		} else {
			stop('I can\'t handle more than 71 ranks. Please provide a colour vector.')
		}
		# colours = case_when(
							#num <= 22 ~ c('grey69',cols_21),
							#num <= 32 ~ c('grey69',cols_31),
							#num <= 61 ~ c('grey69',cols_60),
							#num > 61 ~ c('grey69',cols_70))
	} else if (is.null(names(colours))) {
	    num = length(unique(taxa_df[,rank]))
		colours = c('grey69',rev(colours[1:(num-1)]))
	}

	# Make sure the x axis is categorical
	taxa_df[,sample] = factor(taxa_df[,sample])

	# If the colour vector is named, make sure it is ordered like the factor
	# it's colouring
	if (!is.null(names(colours))) {
	    taxa_df[,rank] = droplevels(taxa_df[,rank])
	    if (!all(levels(taxa_df[,rank]) %in% names(colours))){
	        stop('The colour vector names need to match the rank levels')
	    }

	    colours = colours[levels(taxa_df[,rank])]
	}

	indiv = ggplot(taxa_df, aes_string(x = sample, y = abund, fill = rank,
									   colour = rank)) +
	    theme(axis.title.x = element_blank(),
			axis.text.x = element_text(size = 10,
									   angle = 90,
									   hjust = 1,
									   vjust = 0.5)) +
	    scale_fill_manual(values = colours,
	                      guide = guide_legend(reverse = TRUE)) +
	    scale_colour_manual(values = colours,
	                        guide = guide_legend(reverse = TRUE)) +
	    ylab(paste("Relative Abundance (",rank,")\n",sep=''))
	if (means){
	    indiv = indiv + geom_bar(stat = 'identity', position = 'fill')
	} else {
	    indiv = indiv + geom_bar(stat = "identity")
	}

	if (yscale == 'sqrt') {
		indiv = indiv + scale_y_sqrt()
	}

	if (legloc == 'bottom'){
	    indiv = indiv + theme(legend.position = 'bottom')
	} else if (legloc == 'none') {
	    indiv = indiv + guides(fill = FALSE, colour = FALSE)
	}
	indiv + theme_bw()

	return(indiv)
}

